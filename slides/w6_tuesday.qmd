---
title: "Week 6 – Control Flow, Iteration, and Functions"
subtitle: "+ Mid-term Project Discussion"
format:
  revealjs:
    slide-number: true
    preview-links: auto
    revealjs-plugins:
      - appearance
      - highlight-text
    css: styles.css
    mermaid:
      theme: neutral
footer: 'BANA 4080'
title-slide-attributes:
    data-background-image: images/programming-background.png
    data-background-size: cover
    data-background-opacity: "0.90"
filters: 
  - timer
execute:
    echo: true
---

## Welcome to Week 6

**Today's Agenda:**

- Week 5 Review & Business Pop Quiz
- Control statements for business logic
- Iteration for automation
- Functions for reusable code
- Mid-term project discussion & timeline

# Week 5 Review & Pop Quiz {background="#43464B"}

## Quick Review: Data Visualization Tools {.smaller}

Last week we covered three main approaches to visualization in Python:

| Tool           | Purpose                    | Best Use Cases                        |
| -------------- | -------------------------- | ------------------------------------- |
| **Pandas**     | Quick exploratory plots    | Fast EDA during analysis              |
| **Matplotlib** | Polished, customized plots | Reports, presentations, publications  |
| **Bokeh**      | Interactive visualizations | Dashboards, user exploration tools    |

## Business Scenarios Pop Quiz {.smaller}

::: {.callout}
## Scenario-Based Questions

I'll present 4 real business scenarios. For each one, think about:

- What visualization approach would you recommend?
- What type of chart would be most effective?
- What business insights are you trying to reveal?
:::

:::: {.columns}
::: {.column width='70%'}
Work with a partner and be ready to explain your reasoning!
:::
::: {.column width='30%'}
<center>

<div id="5minQuiz"></div>
<script src="_extensions/produnis/timer/timer.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        initializeTimer("5minQuiz", 300, "slide"); 
    });
</script>
</center>
:::
::::

## Pop Quiz Question 1 {.smaller}

::: {.callout}
## Scenario 1: Monthly Sales Report

Your manager wants to see monthly sales trends across 5 different product categories for the past 2 years. This will be presented to executives in a formal quarterly business review.

**Your recommendation:**

- Visualization tool?
- Chart type?
- Why this choice?
:::

## Pop Quiz Question 2 {.smaller}

::: {.callout}
## Scenario 2: Customer Segmentation Exploration

You've just finished clustering analysis and identified 6 customer segments. The marketing team wants to explore these segments interactively - filtering by demographics, purchase behavior, and geographic region.

**Your recommendation:**

- Visualization tool?
- Chart type?
- Why this choice?
:::

## Pop Quiz Question 3 {.smaller}

::: {.callout}
## Scenario 3: Data Quality Check

You've just received a new dataset with customer transaction data. You need to quickly check for missing values, outliers, and basic patterns before starting your analysis.

**Your recommendation:**

- Visualization tool?
- Chart type?
- Why this choice?
:::

## Pop Quiz Question 4 {.smaller}

::: {.callout}
## Scenario 4: Marketing Spend vs Revenue

A stakeholder asks: "What's the relationship between our digital marketing spend and online revenue?" You need to analyze this relationship and present findings that could influence next quarter's marketing budget.

**Your recommendation:**

- Visualization tool?
- Chart type?
- Why this choice?
:::

## Quick Debrief {.smaller}

**Key takeaways from the pop quiz:**

- **Context drives choice** - same data, different tools depending on audience and purpose
- **Pandas** for quick data exploration and quality checks
- **Matplotlib** for polished presentations to executives
- **Bokeh** for interactive exploration by business users
- **Chart type matters** - match the visual to the business question

**Any lingering questions from Week 5?**

# Control Statements for Business Logic {background="#43464B"}

## Why Programs Need to "Make Decisions" {.smaller}

In business, we constantly make decisions based on conditions:

:::: {.columns}
::: {.column}
**Business Examples:**

- If customer is VIP → offer premium discount
- If inventory is low → reorder products  
- If sales exceed target → pay bonus
- If credit score is high → approve loan
:::
::: {.column}
**Python Equivalent:**
```python
if customer_type == 'VIP':
    discount = 0.20
elif customer_type == 'Premium':
    discount = 0.15
else:
    discount = 0.05
```
:::
::::

**Control statements let your code make business decisions automatically.**

## Scenario 1: Simple `if` Statement {.smaller}

**Business Context:** *"Alert warehouse staff when inventory is critically low"*

When you just need to check one condition and take action if it's true:

```{python}
# Check current inventory level
stock_level = 5

if stock_level < 10:
    print("🚨 URGENT: Reorder needed!")

# Business continues regardless
print(f"Current stock: {stock_level} units")
```

```{python}
# Try with higher inventory
stock_level = 50

if stock_level < 10:
    print("🚨 URGENT: Reorder needed!")
    
print(f"Current stock: {stock_level} units")
```

## Scenario 2: `if/else` Statement {.smaller}

**Business Context:** *"Apply VIP discount pricing for premium customers"*

When you have exactly two paths - do one thing OR another:

```{python}
# VIP customer example
base_price = 100
is_vip = True

if is_vip:
    final_price = base_price * 0.8  # 20% VIP discount
    print(f"VIP discount applied! Price: ${final_price}")
else:
    final_price = base_price
    print(f"Standard price: ${final_price}")
```

```{python}
# Regular customer example  
base_price = 100
is_vip = False

if is_vip:
    final_price = base_price * 0.8  # 20% VIP discount
    print(f"VIP discount applied! Price: ${final_price}")
else:
    final_price = base_price
    print(f"Standard price: ${final_price}")
```

## Scenario 3: `if/elif/else` Statement {.smaller .scrollable}

**Business Context:** *"Segment customers by annual spending for targeted marketing"*

When you have multiple categories to check in order:

```{python}
# High-value customer example
annual_spend = 12500

if annual_spend >= 10000:
    segment = "High Value"
    strategy = "Personal account manager"
elif annual_spend >= 5000:
    segment = "Medium Value"
    strategy = "Quarterly check-ins"
elif annual_spend >= 1000:
    segment = "Low Value"
    strategy = "Email campaigns"
else:
    segment = "Inactive"
    strategy = "Re-engagement campaign"

print(f"Customer segment: {segment} → {strategy}")
```

```{python}
# Low-value customer example
annual_spend = 3000

if annual_spend >= 10000:
    segment = "High Value"
    strategy = "Personal account manager"
elif annual_spend >= 5000:
    segment = "Medium Value"
    strategy = "Quarterly check-ins"
elif annual_spend >= 1000:
    segment = "Low Value"
    strategy = "Email campaigns"
else:
    segment = "Inactive"
    strategy = "Re-engagement campaign"

print(f"Customer segment: {segment} → {strategy}")
```

## Business Logic: Complex Discount Rules {.smaller}

**Business Context:** *"Combine multiple discount rules for sophisticated pricing"*

```{python}
# VIP customer with large order and membership - Example 1
customer_type = 'VIP'
order_amount = 600
is_member = True

base_discount = 0

# VIP customers always get 15% minimum
if customer_type == 'VIP':
    base_discount = 0.15
elif customer_type == 'Premium':
    base_discount = 0.10

# Large orders get additional discount
if order_amount > 500:
    base_discount += 0.05

# Loyalty members get extra 5%
if is_member:
    base_discount += 0.05

# Cap maximum discount at 25%
final_discount = min(base_discount, 0.25)

print(f"VIP customer final discount: {final_discount:.1%}")
```

```{python}
# Premium customer with small order, no membership - Example 2
customer_type = 'Premium'
order_amount = 300
is_member = False

base_discount = 0

# VIP customers always get 15% minimum
if customer_type == 'VIP':
    base_discount = 0.15
elif customer_type == 'Premium':
    base_discount = 0.10

# Large orders get additional discount
if order_amount > 500:
    base_discount += 0.05

# Loyalty members get extra 5%
if is_member:
    base_discount += 0.05

# Cap maximum discount at 25%
final_discount = min(base_discount, 0.25)

print(f"Premium customer final discount: {final_discount:.1%}")
```

## Dictionary-Based Business Rules {.smaller .scrollable}

**Business Context:** *"SaaS company needs dynamic pricing lookup for subscription tiers"*

Your company offers software subscriptions with different pricing tiers. Rather than writing long if/elif chains to determine pricing, you can use Python dictionaries for clean, maintainable pricing logic.

**Why dictionaries beat if/elif chains:**

- **Cleaner code:** No nested conditions to debug
- **Easy updates:** Change prices in one place  
- **Scalable:** Add new tiers without touching logic
- **Data-driven:** Pricing rules can come from databases

```{python}
# Product pricing rules
pricing_tiers = {
    'basic': 29.99,
    'premium': 49.99,
    'enterprise': 99.99,
    'custom': None  # requires quote
}

# Look up premium tier pricing
pricing_tiers.get('premium', "Contact sales")
```

```{python}
# Look up basic tier pricing
pricing_tiers.get('basic', "Contact sales")
```

```{python}
# Look up invalid tier (demonstrates default behavior)
pricing_tiers.get('invalid', "Contact sales")
```

**When to use:** Clean, readable rules that map inputs to outputs.

## Vectorized Conditionals in Pandas {.smaller}

**Business Context:** *"Segment thousands of customers efficiently"*

**For large datasets, use pandas instead of loops:**

```{python}
import pandas as pd

# Sample customer data
customers = pd.DataFrame({
    'customer_id': [1, 2, 3, 4, 5],
    'annual_spend': [15000, 3000, 8000, 500, 12000],
    'years_active': [5, 1, 3, 0.5, 7]
})

# Vectorized customer segmentation - processes all rows at once!
customers['segment'] = pd.cut(
    customers['annual_spend'], 
    bins=[0, 1000, 5000, 10000, float('inf')],
    labels=['Inactive', 'Low', 'Medium', 'High']
)

print("Customer segmentation results:")
print(customers[['customer_id', 'annual_spend', 'segment']])
```

# Iteration for Business Automation {background="#43464B"}

## Why Automate Repetitive Business Tasks? {.smaller}

**Common business scenarios where iteration saves time:**

:::: {.columns}
::: {.column}

- **Processing monthly reports** from multiple stores
- **Calculating metrics** across product categories
- **Data quality checks** on multiple datasets
- **Sending personalized emails** to customer segments
- **Applying transformations** across time periods
:::
::: {.column}
**Before automation:**

- Manual work for each file/category
- Error-prone copy/paste
- Hours of repetitive tasks

**After automation:**

- Write once, run many times
- Consistent results
- Focus on analysis, not busy work
:::
::::

## Business Example: Why Use for Loops? {.smaller}

**Business Context:** *"Calculate sales commission for each sales representative"*

Your company has 5 sales reps with different sales amounts. You need to calculate 10% commission for each.

:::: {.columns}
::: {.column}
**Manual approach (repetitive):**
```python
# Rep 1
sales_rep1 = 45000
commission1 = sales_rep1 * 0.10

# Rep 2  
sales_rep2 = 52000
commission2 = sales_rep2 * 0.10

# Rep 3
sales_rep3 = 38000
commission3 = sales_rep3 * 0.10
# ... continue for all reps
```
:::
::: {.column}
**for loop approach (automated):**
```python
sales_amounts = [45000, 52000, 38000, 41000, 67000]

for sales in sales_amounts:
    commission = sales * 0.10
    print(f"Sales: ${sales:,} → Commission: ${commission:,}")
```
:::
::::

**Result:** Same calculation applied consistently to all data with less code and fewer errors.

## for Loops: Processing Store Performance {.smaller}

**Scenario:** Calculate performance metrics for multiple store locations

```{python}
# Store sales data for 5 locations
stores = [
    {'name': 'Downtown', 'sales': 125000, 'target': 100000},
    {'name': 'Mall', 'sales': 98000, 'target': 110000},
    {'name': 'Suburbs', 'sales': 142000, 'target': 120000},
    {'name': 'Airport', 'sales': 87000, 'target': 90000},
    {'name': 'University', 'sales': 156000, 'target': 140000}
]

# Calculate performance for each store
print("Store Performance Report:")
print("-" * 40)

for store in stores:
    performance = (store['sales'] / store['target']) * 100
    status = "✅ Above Target" if performance >= 100 else "❌ Below Target"
    
    print(f"{store['name']:12} | {performance:5.1f}% | {status}")
```

## while Loops: Conditional Processing {.smaller .scrollable}

**Business Context:** *"Automate inventory monitoring to prevent stockouts"*

Your company needs to track product inventory daily and trigger reorders automatically when stock gets too low. Unlike `for` loops that run a fixed number of times, `while` loops continue until a condition is met - perfect for monitoring situations.

**When to use while loops:**

- You don't know exactly how many iterations you need
- You want to continue until a specific business condition is reached
- You're monitoring thresholds, limits, or targets

## while Loops: Conditional Processing {.smaller .scrollable}

**Business Context:** *"Automate inventory monitoring to prevent stockouts"*

**Scenario:** Track daily inventory until reorder threshold is reached

```{python}
# Starting inventory and business rules
current_inventory = 1000
reorder_threshold = 200
days = 0

# Daily sales amounts (simulating a week)
daily_sales = [95, 120, 85, 110, 140, 75, 130]

print("Daily Inventory Tracking:")
print("-" * 35)

# Process sales until we need to reorder
sale_index = 0
while current_inventory > reorder_threshold and sale_index < len(daily_sales):
    # Process today's sales
    today_sales = daily_sales[sale_index]
    current_inventory -= today_sales
    days += 1
    sale_index += 1
    
    print(f"Day {days}: Sold {today_sales:3d} | Remaining: {current_inventory:3d}")

print("-" * 35)
if current_inventory <= reorder_threshold:
    print(f"🚨 Reorder needed after {days} days!")
    print(f"Current inventory: {current_inventory} units")
else:
    print("✅ Inventory still sufficient")
```

## List Comprehensions for Data Transformations {.smaller .scrollable}

**Business Context:** *"Apply 15% discount to all product prices"*

List comprehensions let you create new lists in one line instead of writing loops:

```{python}
# Original product prices
original_prices = [29.99, 49.99, 19.99, 89.99, 15.99]
```

<br>

```{python}
# Traditional for loop approach
discounted_prices_loop = []
for price in original_prices:
    new_price = price * 0.85  # Apply 15% discount
    discounted_prices_loop.append(new_price)

print("For loop result:", discounted_prices_loop)
```

<br>

```{python}
# List comprehension approach (same result, one line!)
discounted_prices_comp = [price * 0.85 for price in original_prices]

print("List comprehension result:", discounted_prices_comp)

# Syntax comparison:
# [EXPRESSION for ITEM in LIST]
#     ↑           ↑        ↑
#   what to do   loop   source data
```

## When to Use Loops vs Pandas Operations {.smaller}

**Use pandas vectorized operations when possible:**

:::: {.columns}
::: {.column}
**❌ Slow (loop over rows):**
```python
# Don't do this
for idx, row in df.iterrows():
    if row['sales'] > 1000:
        df.loc[idx, 'bonus'] = 100
    else:
        df.loc[idx, 'bonus'] = 0
```
:::
::: {.column}
**✅ Fast (vectorized):**
```python
# Do this instead
df['bonus'] = df['sales'].apply(
    lambda x: 100 if x > 1000 else 0
)

# Or even better
df['bonus'] = np.where(
    df['sales'] > 1000, 100, 0
)
```
:::
::::

**Use loops for:** File processing, API calls, complex business logic  
**Use pandas for:** Column calculations, filtering, aggregations

# Functions for Reusable Code {background="#43464B"}

## Why Business Analysts Need Functions {.smaller}

**The DRY Principle: Don't Repeat Yourself**

:::: {.columns}
::: {.column}
**Without functions:**
```python
# Calculate ROI for Campaign A
roi_a = (revenue_a - cost_a) / cost_a * 100

# Calculate ROI for Campaign B  
roi_b = (revenue_b - cost_b) / cost_b * 100

# Calculate ROI for Campaign C
roi_c = (revenue_c - cost_c) / cost_c * 100
```
:::
::: {.column}
**With functions:**
```python
def calculate_roi(revenue, cost):
    return (revenue - cost) / cost * 100

roi_a = calculate_roi(revenue_a, cost_a)
roi_b = calculate_roi(revenue_b, cost_b)
roi_c = calculate_roi(revenue_c, cost_c)
```
:::
::::

**Benefits:** Less code, fewer errors, easier to modify, clearer intent

## Function Basics: Building Blocks {.smaller}

**Business Context:** *"Create reusable code for repeated business calculations"*

Every function has 4 key components:

```{python}
def calculate_sales_tax(price, tax_rate=0.08):
    """
    Calculate sales tax for a given price.
    
    Args:
        price (float): The base price of the item
        tax_rate (float): Tax rate as decimal (default 8%)
    
    Returns:
        float: The tax amount
    """
    tax_amount = price * tax_rate
    return tax_amount

# Using the function
item_price = 100.00
tax = calculate_sales_tax(item_price)
print(f"Tax on ${item_price}: ${tax:.2f}")

# Using with custom tax rate
tax_custom = calculate_sales_tax(item_price, 0.10)
print(f"Tax with 10% rate: ${tax_custom:.2f}")
```

**Four key parts:** `def` name, arguments, docstring, `return`

## Business Metrics Functions {.smaller .scrollable}

**Business Context:** *"Calculate key performance indicators consistently across the organization"*

Your marketing team needs to calculate Customer Lifetime Value (CLV) for different customer segments to guide acquisition spending. Instead of recreating this calculation in every analysis, you create a reusable function.

```{python}
def customer_lifetime_value(avg_order_value, purchase_frequency, 
                           gross_margin, customer_lifespan):
    """
    Calculate Customer Lifetime Value (CLV)
    
    Args:
        avg_order_value: Average amount spent per order
        purchase_frequency: Purchases per year
        gross_margin: Profit margin (as decimal, e.g., 0.20 for 20%)
        customer_lifespan: Expected years as customer
    
    Returns:
        CLV in dollars
    """
    annual_value = avg_order_value * purchase_frequency * gross_margin
    clv = annual_value * customer_lifespan
    return round(clv, 2)

# Usage
clv = customer_lifetime_value(
    avg_order_value=150,
    purchase_frequency=4,
    gross_margin=0.25,
    customer_lifespan=3
)
print(f"Customer Lifetime Value: ${clv}")
```

## Data Cleaning Pipeline Functions {.smaller .scrollable}

**Business Context:** *"Standardize data processing across multiple datasets from different sources"*

Your company receives customer data from various sources (website, CRM, mobile app) with different formats and quality issues. Instead of cleaning each dataset manually, you create standardized functions to ensure consistent data quality.

```python
def clean_customer_data(df):
    """Standardized data cleaning for customer datasets"""
    
    # Remove duplicates
    df = df.drop_duplicates()
    
    # Standardize phone numbers
    df['phone'] = df['phone'].str.replace(r'[^\d]', '', regex=True)
    
    # Clean email addresses
    df['email'] = df['email'].str.lower().str.strip()
    
    # Handle missing values
    df['age'] = df['age'].fillna(df['age'].median())
    df['income'] = df['income'].fillna(df['income'].median())
    
    return df

def validate_data_quality(df, required_columns):
    """Check data quality and return summary"""
    
    missing_cols = [col for col in required_columns if col not in df.columns]
    missing_data = df.isnull().sum()
    
    return {
        'missing_columns': missing_cols,
        'missing_data': missing_data.to_dict(),
        'total_rows': len(df)
    }
```

## Lambda Functions for Quick Transformations {.smaller .scrollable}

**For simple, one-line transformations:**

```{python}
import pandas as pd

# Sample sales data
sales = pd.DataFrame({
    'product': ['A', 'B', 'C', 'D'],
    'revenue': [1200, 800, 1500, 950],
    'cost': [600, 500, 900, 400]
})

# Calculate profit using lambda
sales['profit'] = sales.apply(lambda row: row['revenue'] - row['cost'], axis=1)

# Categorize performance using lambda
sales['performance'] = sales['profit'].apply(
    lambda x: 'High' if x > 600 else ('Medium' if x > 400 else 'Low')
)

print(sales)
```

**When to use:** Simple transformations, pandas apply operations  
**When not to use:** Complex logic, reusable across projects

## Function Documentation for Team Collaboration {.smaller}

```python
def calculate_churn_risk(days_since_last_purchase, avg_purchase_frequency, 
                        customer_complaints, discount_usage_rate):
    """
    Calculate customer churn risk score.
    
    Args:
        days_since_last_purchase (int): Days since last order
        avg_purchase_frequency (float): Average days between purchases
        customer_complaints (int): Number of complaints in last 6 months
        discount_usage_rate (float): Fraction of purchases using discounts (0-1)
    
    Returns:
        float: Churn risk score from 0-100 (higher = more likely to churn)
    
    Example:
        >>> calculate_churn_risk(45, 30, 2, 0.8)
        75.5
    """
    # Risk increases with time since last purchase
    recency_risk = min((days_since_last_purchase / avg_purchase_frequency) * 30, 50)
    
    # Risk increases with complaints
    complaint_risk = customer_complaints * 10
    
    # High discount usage may indicate price sensitivity
    discount_risk = discount_usage_rate * 20
    
    total_risk = recency_risk + complaint_risk + discount_risk
    return min(total_risk, 100)  # Cap at 100
```

# Mid-term Project Discussion {background="#43464B"}

## Mid-term Timeline: We're Getting Close! {.smaller}

**Timeline:**

- **Today:** Discuss project requirements and expectations
- **Thursday Lab:** Form groups, explore dataset, brainstorm questions  
- **Next Tuesday:** Project work session & check-ins
- **Next Thursday:** Final work session, presentations begin
- **Deadline:** End of next week

**Why discuss today?** You have **2 dedicated lab sessions** to work on this!

## Project Scenario Reminder {.smaller}

**You are data scientists at Regork, a national grocery chain.**

**Your mission:** Identify a potential area of growth that could increase revenue or profits.

**Deliverables:**

1. **Written report** (3-4 pages) with business question, analysis, and recommendations
2. **3-minute presentation** for the CEO

**Dataset:** Complete Journey grocery transaction data (customers, products, transactions, promotions)

## Team Formation Guidelines {.smaller}

**Group Size:** 2-4 students

**Forming your team:**

- Mix of skills/backgrounds if possible
- Clear communication expectations
- Decide on meeting times early

**This Thursday:** Come to lab ready to:

- Form your group
- Explore the dataset together  
- Start brainstorming business questions
- Divide initial tasks

## Choosing Your Business Question {.smaller}

**Good business questions are:**

- **Specific and actionable** - not too broad
- **Answerable with the available data**
- **Relevant to business growth/profit**

**Example progression:**

❌ "What products sell well?" (too broad)  
❌ "Do customers like organic food?" (can't answer with transaction data)  
✅ "Which product categories show seasonal purchasing patterns that could inform promotional timing?"

## Example Business Questions {.smaller}

**Market Basket Analysis:**

- Which products are frequently purchased together?
- Can we identify cross-selling opportunities?

**Customer Behavior:**

- Do purchasing patterns vary by demographic segments?
- Which customers are most responsive to promotions?

**Seasonal/Temporal Patterns:**

- How do sales patterns change throughout the year?
- What drives weekend vs weekday shopping differences?

**Promotion Effectiveness:**

- Which types of promotions generate the highest revenue lift?
- Do certain customer segments respond better to specific promotion types?

## What Makes a Strong Project {.smaller}

**Technical Requirements:**

- Data cleaning and preprocessing
- Multiple visualizations (using skills from Week 5!)
- Statistical analysis or aggregations
- Clear analytical methodology

**Business Impact:**

- Clear connection to revenue/profit opportunity
- Actionable recommendations
- Realistic implementation suggestions
- Quantified potential impact when possible

**Presentation:**

- Tell a compelling story
- Focus on insights, not just analysis
- Professional visuals
- Strong business case

## Grading Criteria Overview {.smaller}

**Written Report (60%):**

- Clarity of business question (15%)
- Quality of analysis and methodology (20%)
- Visualization quality and appropriateness (15%)
- Insights and recommendations (10%)

**Presentation (30%):**

- Clear communication (15%)
- Business focus and impact (15%)

**Collaboration (10%):**

- Team contribution and collaboration

**We'll discuss detailed rubric next week!**

## Getting Started: Thursday Lab Plan {.smaller}

**What to do Thursday:**

1. **Form groups** (first 15 minutes)
2. **Dataset exploration** - load data, understand structure
3. **Brainstorm questions** - what business problems interest you?
4. **Preliminary analysis** - start exploring patterns
5. **Plan next steps** - divide tasks, set meeting times

**Come prepared with:**

- Ideas about what business problems interest you
- Willingness to collaborate
- Laptop/Colab access for data exploration

## Questions & Discussion

**Open floor for questions about:**

- Control statements, iteration, and functions
- Mid-term project requirements
- Team formation process
- Dataset or analysis approaches
- Timeline and expectations

# Summary and Next Steps {background="#43464B"}

## Key Takeaways {.smaller}

**Today we covered:**

1. **Control statements** - Making business decisions in code
2. **Iteration** - Automating repetitive business tasks  
3. **Functions** - Creating reusable, maintainable code
4. **Mid-term project** - Timeline, requirements, and expectations

**Next steps:**

- **Thursday:** Lab work on control flow + mid-term group formation
- **Read:** Chapters 16-18 in the textbook
- **Start thinking:** What business questions interest you for the mid-term?

**Remember:** These programming concepts make you more efficient and your code more professional!